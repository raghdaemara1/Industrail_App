<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Industrail_App ‚Äî Full System Data Flow (Production Version)</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400;500;600&family=IBM+Plex+Sans:wght@300;400;500;600;700&display=swap');

    :root {
      --bg: #0A0C0F;
      --surface: #0F1318;
      --panel: #141920;
      --border: #1E2530;
      --border2: #252F3D;
      --ink: #CDD9E5;
      --muted: #5E6E82;
      --dim: #3A4A5C;

      --amber: #E8A020;
      --amber-bg: #1A1208;
      --blue: #4D9EFF;
      --blue-bg: #080F1A;
      --purple: #A47FE8;
      --purple-bg: #0E0A18;
      --teal: #2FD8C4;
      --teal-bg: #061410;
      --green: #3ACF7A;
      --green-bg: #071210;
      --red: #FF6B6B;
      --red-bg: #180808;

      --mono: 'IBM Plex Mono', monospace;
      --sans: 'IBM Plex Sans', sans-serif;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: var(--bg);
      color: var(--ink);
      font-family: var(--sans);
      min-height: 100vh;
      overflow-x: hidden;
    }

    /* ‚îÄ‚îÄ grid noise texture overlay ‚îÄ‚îÄ */
    body::before {
      content: '';
      position: fixed;
      inset: 0;
      background-image:
        radial-gradient(circle at 20% 50%, rgba(77, 158, 255, 0.03) 0%, transparent 50%),
        radial-gradient(circle at 80% 20%, rgba(164, 127, 232, 0.03) 0%, transparent 50%);
      pointer-events: none;
      z-index: 0;
    }

    .wrap {
      position: relative;
      z-index: 1;
      max-width: 1360px;
      margin: 0 auto;
      padding: 48px 32px 80px;
    }

    /* ‚îÄ‚îÄ header ‚îÄ‚îÄ */
    .header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 56px;
      padding-bottom: 24px;
      border-bottom: 1px solid var(--border2);
    }

    .header-left h1 {
      font-family: var(--mono);
      font-size: 11px;
      font-weight: 500;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: var(--muted);
      margin-bottom: 10px;
    }

    .header-left h2 {
      font-family: var(--mono);
      font-size: 22px;
      font-weight: 600;
      color: var(--ink);
      letter-spacing: -0.02em;
    }

    .header-left h2 span {
      color: var(--green);
    }

    .version-badge {
      background: var(--panel);
      border: 1px solid var(--border2);
      border-radius: 4px;
      padding: 8px 16px;
      font-family: var(--mono);
      font-size: 11px;
      color: var(--muted);
    }

    /* ‚îÄ‚îÄ PIPELINE CONTAINER ‚îÄ‚îÄ */
    .pipeline {
      display: flex;
      flex-direction: column;
      gap: 0;
    }

    /* ‚îÄ‚îÄ phase label ‚îÄ‚îÄ */
    .phase-label {
      font-family: var(--mono);
      font-size: 10px;
      font-weight: 500;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: var(--muted);
      margin: 40px 0 12px;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .phase-label::after {
      content: '';
      flex: 1;
      height: 1px;
      background: linear-gradient(90deg, var(--border2), transparent);
    }

    .phase-label:first-child {
      margin-top: 0;
    }

    /* ‚îÄ‚îÄ NODES ‚îÄ‚îÄ */
    .flow-row {
      display: grid;
      gap: 12px;
      align-items: stretch;
      margin-bottom: 4px;
    }

    .flow-row.cols-1 {
      grid-template-columns: 1fr;
    }

    .flow-row.cols-3 {
      grid-template-columns: repeat(3, 1fr);
    }

    .flow-row.cols-5 {
      grid-template-columns: repeat(5, 1fr);
    }

    .flow-row.cols-2 {
      grid-template-columns: 1fr 1fr;
    }

    .flow-row.cols-4 {
      grid-template-columns: repeat(4, 1fr);
    }

    .node {
      background: var(--panel);
      border: 1px solid var(--border2);
      border-radius: 8px;
      padding: 18px 20px;
      position: relative;
      transition: border-color 0.2s, background 0.2s;
      cursor: default;
    }

    .node:hover {
      background: #192030;
    }

    .node-icon {
      font-size: 20px;
      margin-bottom: 10px;
      display: block;
    }

    .node-title {
      font-family: var(--mono);
      font-size: 12px;
      font-weight: 600;
      margin-bottom: 4px;
      letter-spacing: 0.01em;
    }

    .node-sub {
      font-size: 11px;
      color: var(--muted);
      font-family: var(--mono);
      margin-bottom: 10px;
    }

    .node-desc {
      font-size: 12px;
      color: #8A9AB0;
      line-height: 1.65;
    }

    .node-tag {
      display: inline-block;
      margin-top: 10px;
      padding: 3px 8px;
      border-radius: 3px;
      font-family: var(--mono);
      font-size: 10px;
      font-weight: 500;
      letter-spacing: 0.08em;
    }

    /* color variants */
    .amber {
      border-color: var(--amber);
    }

    .amber .node-title {
      color: var(--amber);
    }

    .amber .node-tag {
      background: var(--amber-bg);
      color: var(--amber);
    }

    .blue {
      border-color: var(--blue);
    }

    .blue .node-title {
      color: var(--blue);
    }

    .blue .node-tag {
      background: var(--blue-bg);
      color: var(--blue);
    }

    .purple {
      border-color: var(--purple);
    }

    .purple .node-title {
      color: var(--purple);
    }

    .purple .node-tag {
      background: var(--purple-bg);
      color: var(--purple);
    }

    .teal {
      border-color: var(--teal);
    }

    .teal .node-title {
      color: var(--teal);
    }

    .teal .node-tag {
      background: var(--teal-bg);
      color: var(--teal);
    }

    .green {
      border-color: var(--green);
    }

    .green .node-title {
      color: var(--green);
    }

    .green .node-tag {
      background: var(--green-bg);
      color: var(--green);
    }

    .red {
      border-color: var(--red);
    }

    .red .node-title {
      color: var(--red);
    }

    .red .node-tag {
      background: var(--red-bg);
      color: var(--red);
    }

    /* ‚îÄ‚îÄ ARROWS ‚îÄ‚îÄ */
    .arrow-row {
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 6px 0;
      gap: 16px;
    }

    .arrow-row.spread {
      justify-content: space-around;
      padding: 6px 40px;
    }

    .arrow-row.spread5 {
      justify-content: space-around;
      padding: 6px 20px;
    }

    .arrow {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
    }

    .arrow-label {
      font-family: var(--mono);
      font-size: 9px;
      color: var(--dim);
      letter-spacing: 0.1em;
      text-transform: uppercase;
      text-align: center;
    }

    .arrow-line {
      width: 1px;
      height: 24px;
      background: linear-gradient(180deg, var(--border2), var(--border2));
      position: relative;
    }

    .arrow-line::after {
      content: '‚ñº';
      position: absolute;
      bottom: -10px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 8px;
      color: var(--dim);
    }

    .arrow-h {
      display: flex;
      align-items: center;
      gap: 4px;
      font-family: var(--mono);
      font-size: 9px;
      color: var(--dim);
    }

    .arrow-line.green-flow {
      background: linear-gradient(180deg, var(--green), var(--green)33);
    }

    .arrow-line.green-flow::after {
      color: var(--green);
    }

    .arrow-line.amber-flow {
      background: linear-gradient(180deg, var(--amber), var(--amber)33);
    }

    .arrow-line.amber-flow::after {
      color: var(--amber);
    }

    .arrow-line.red-flow {
      background: linear-gradient(180deg, var(--red), var(--red)33);
    }

    .arrow-line.red-flow::after {
      color: var(--red);
    }

    /* ‚îÄ‚îÄ DIVIDER ‚îÄ‚îÄ */
    .divider {
      height: 1px;
      background: linear-gradient(90deg, transparent, var(--border2) 20%, var(--border2) 80%, transparent);
      margin: 32px 0;
    }

    /* ‚îÄ‚îÄ QA SECTION ‚îÄ‚îÄ */
    .qa-section {
      margin-top: 64px;
    }

    .qa-header {
      font-family: var(--mono);
      font-size: 10px;
      font-weight: 500;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: var(--muted);
      margin-bottom: 24px;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .qa-header::before,
    .qa-header::after {
      content: '';
      flex: 1;
      height: 1px;
      background: linear-gradient(90deg, transparent, var(--border2));
    }

    .qa-header::before {
      background: linear-gradient(90deg, var(--border2), transparent);
    }

    .qa-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 16px;
    }

    .qa-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-left: 3px solid var(--muted);
      border-radius: 0 8px 8px 0;
      padding: 20px 22px;
      transition: border-left-color 0.2s;
    }

    .qa-card:hover {
      border-left-color: var(--blue);
    }

    .qa-card:hover .qa-q {
      color: var(--blue);
    }

    .qa-q {
      font-family: var(--mono);
      font-size: 12px;
      font-weight: 600;
      color: var(--ink);
      margin-bottom: 10px;
      line-height: 1.5;
    }

    .qa-a {
      font-size: 13px;
      color: #7A8EA8;
      line-height: 1.7;
    }

    .qa-a code {
      font-family: var(--mono);
      font-size: 11px;
      background: var(--panel);
      border-radius: 3px;
      padding: 1px 5px;
      color: var(--teal);
    }

    .qa-a strong {
      color: var(--ink);
      font-weight: 500;
    }

    /* ‚îÄ‚îÄ flow connector boxes (multi-node rows) ‚îÄ‚îÄ */
    .connector {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 8px 0;
      font-family: var(--mono);
      font-size: 9px;
      color: var(--dim);
      gap: 8px;
    }

    .connector-line {
      flex: 1;
      height: 1px;
      background: var(--border2);
      max-width: 60px;
    }

    /* storage row */
    .storage-row {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 12px;
      margin-top: 4px;
    }

    .storage-node {
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 12px 14px;
      text-align: center;
    }

    .storage-node .s-name {
      font-family: var(--mono);
      font-size: 11px;
      font-weight: 600;
      margin-bottom: 3px;
    }

    .storage-node .s-type {
      font-family: var(--mono);
      font-size: 9px;
      color: var(--muted);
    }

    /* ‚îÄ‚îÄ legend ‚îÄ‚îÄ */
    .legend {
      display: flex;
      gap: 24px;
      align-items: center;
      margin-top: 32px;
      padding-top: 20px;
      border-top: 1px solid var(--border);
      flex-wrap: wrap;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-family: var(--mono);
      font-size: 10px;
      color: var(--muted);
    }

    .legend-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }

    .legend-line-h {
      width: 20px;
      height: 1px;
    }

    /* cortex dual box */
    .cortex-dual {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    .cortex-half {
      border-radius: 5px;
      padding: 10px 12px;
      font-size: 11px;
      line-height: 1.5;
    }

    .cortex-half .ch-title {
      font-family: var(--mono);
      font-size: 10px;
      font-weight: 600;
      margin-bottom: 5px;
    }

    .cortex-half .ch-body {
      color: #7A8EA8;
      font-size: 11px;
    }

    @media (max-width: 900px) {
      .flow-row.cols-5 {
        grid-template-columns: repeat(2, 1fr);
      }

      .storage-row {
        grid-template-columns: repeat(2, 1fr);
      }

      .qa-grid {
        grid-template-columns: 1fr;
      }

      .flow-row.cols-3 {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>

<body>
  <div class="wrap">

    <!-- HEADER -->
    <div class="header">
      <div class="header-left">
        <h1>Industrail_App Production Platform</h1>
        <h2>Full System <span>Data Flow</span> ‚Äî PDF in, .xlsx out</h2>
      </div>
      <div class="version-badge">v2.0 ¬∑ Feb 2026 ¬∑ All layers</div>
    </div>

    <div class="pipeline">

      <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê PHASE A: INGESTION ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
      <div class="phase-label">A ‚Äî Ingestion ¬∑ User uploads a PDF manual</div>

      <div class="flow-row cols-1">
        <div class="node amber">
          <span class="node-icon">üìÑ</span>
          <div class="node-title">User ‚Äî Upload PDF Manual</div>
          <div class="node-sub">app/app.py ¬∑ Streamlit UI</div>
          <div class="node-desc">Engineer selects a machine and uploads its PDF documentation (fault guide, parameter
            sheet, or both). The app registers the document with the Doc Intelligence platform using a single API call ‚Äî
            it does not parse the PDF itself.</div>
          <span class="node-tag">ENTRY POINT</span>
        </div>
      </div>

      <div class="arrow-row">
        <div class="arrow">
          <div class="arrow-label">POST /ingest ‚Üí returns [doc_ids]</div>
          <div class="arrow-line amber-flow" style="height:32px;"></div>
        </div>
      </div>

      <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê PHASE B: PARSE ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
      <div class="phase-label">B ‚Äî Parse ¬∑ Raw text extracted from PDF</div>

      <div class="flow-row cols-1">
        <div class="node amber">
          <span class="node-icon">‚öôÔ∏è</span>
          <div class="node-title">Parse ‚Äî Docling / Unstructured</div>
          <div class="node-sub">Storage ‚Üí Azure Blob (object store)</div>
          <div class="node-desc">
            The parser reads the raw PDF bytes and extracts every page ‚Äî text paragraphs, tables, numbered lists,
            images, and captions.
            It does not understand meaning yet. It just converts PDF binary into readable text and structured formats
            (.txt, .md).
            Everything is saved as objects in Azure Blob with metadata (page number, section headers, doc type hints).
            <br><br>
            <strong style="color:#CDD9E5;">Why Azure Blob?</strong> It is an object store ‚Äî designed to hold raw files
            of any format at scale, like a filing cabinet. Every other component reads from here as the single source of
            truth for raw content.
          </div>
          <span class="node-tag">RAW TEXT + METADATA</span>
        </div>
      </div>

      <!-- 5-way fan out -->
      <div class="arrow-row spread5" style="padding:10px 40px;">
        <div class="arrow">
          <div class="arrow-label">raw text</div>
          <div class="arrow-line" style="height:28px;"></div>
        </div>
        <div class="arrow">
          <div class="arrow-label">raw text</div>
          <div class="arrow-line" style="height:28px;"></div>
        </div>
        <div class="arrow">
          <div class="arrow-label">chunks</div>
          <div class="arrow-line" style="height:28px;"></div>
        </div>
        <div class="arrow">
          <div class="arrow-label">entities</div>
          <div class="arrow-line" style="height:28px;"></div>
        </div>
        <div class="arrow">
          <div class="arrow-label">records</div>
          <div class="arrow-line" style="height:28px;"></div>
        </div>
      </div>

      <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê PHASE C: INDEX ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
      <div class="phase-label">C ‚Äî Index ¬∑ Five parallel engines process the raw text simultaneously</div>

      <div class="flow-row cols-5">

        <!-- LEXICAL -->
        <div class="node blue">
          <span class="node-icon">üî§</span>
          <div class="node-title">Lexical BM25</div>
          <div class="node-sub">OpenSearch</div>
          <div class="node-desc">
            Builds a keyword index. Every word in every document is scored by how often it appears (TF) and how rare it
            is across all documents (IDF).
            <br><br>
            <strong style="color:#CDD9E5;">BM25</strong> = Best Match 25. A mathematical formula that ranks documents by
            exact word match. "alarm 282" will always return the exact page that contains those words.
            <br><br>
            <strong style="color:#CDD9E5;">Why OpenSearch?</strong> It is fully open-source (Apache 2.0), runs natively
            on AWS, and supports both BM25 keyword search AND vector search in one engine ‚Äî no separate vector database
            needed.
          </div>
          <span class="node-tag">EXACT LOOKUP</span>
        </div>

        <!-- SEMANTIC -->
        <div class="node purple">
          <span class="node-icon">üß†</span>
          <div class="node-title">Semantic Search</div>
          <div class="node-sub">Cortex ‚Äî Snowflake</div>
          <div class="node-desc">
            Splits text into chunks (~500 words), then runs each chunk through an embedding model. The model converts
            text into a vector ‚Äî 1536 numbers that represent the <em>meaning</em> of the chunk, not the words.
            <br><br>
            <strong style="color:#CDD9E5;">Why vectors?</strong> "inverter overtemperature" and "overheating drive
            problem" produce similar vectors even though they share no words. This enables natural-language search.
            <br><br>
            Query: "find alarms about cooling problems" ‚Üí returns overtemperature, fan fault, heat exchanger alarms ‚Äî
            even without those exact words.
          </div>
          <span class="node-tag">MEANING SEARCH</span>
        </div>

        <!-- CORTEX ANALYTICS -->
        <div class="node purple" style="border-color:#C792EA;">
          <span class="node-icon">üìä</span>
          <div class="node-title">Cortex ‚Äî Analytics</div>
          <div class="node-sub">Snowflake Cortex AI</div>
          <div class="node-desc">
            Cortex is not only a search engine. It is Snowflake's AI runtime for analytics on structured data.
            <br><br>
            <strong style="color:#CDD9E5;">What it does beyond search:</strong>
            <div class="cortex-dual" style="margin-top:8px;">
              <div class="cortex-half" style="background:#120E1E;">
                <div class="ch-title" style="color:#C792EA;">PREDICT</div>
                <div class="ch-body">Fault frequency prediction. Which alarms appear most often? Which machines are at
                  risk? Trained on historical alarm records.</div>
              </div>
              <div class="cortex-half" style="background:#120E1E;">
                <div class="ch-title" style="color:#C792EA;">CLASSIFY</div>
                <div class="ch-body">Run ML classification models on alarm text directly inside Snowflake ‚Äî no data
                  export needed.</div>
              </div>
              <div class="cortex-half" style="background:#120E1E; margin-top:0;">
                <div class="ch-title" style="color:#C792EA;">SUMMARISE</div>
                <div class="ch-body">LLM-powered summarisation of document content ‚Äî extract key themes from hundreds of
                  pages.</div>
              </div>
              <div class="cortex-half" style="background:#120E1E; margin-top:0;">
                <div class="ch-title" style="color:#C792EA;">ANOMALY</div>
                <div class="ch-body">Detect abnormal alarm patterns across machines. Flag new alarm codes that don't
                  match known categories.</div>
              </div>
            </div>
          </div>
          <span class="node-tag">ANALYTICS + ML</span>
        </div>

        <!-- GRAPH -->
        <div class="node teal">
          <span class="node-icon">üï∏</span>
          <div class="node-title">Graph Index</div>
          <div class="node-sub">Neo4j</div>
          <div class="node-desc">
            Extracts entities (Alarm, Component, Machine, Action) and the relationships between them, then stores them
            as a graph.
            <br><br>
            <code
              style="font-family:monospace;font-size:10px;color:#2FD8C4;">(Alarm:282) ‚ÜíCAUSES‚Üí (Component:Inverter) ‚ÜíPART_OF‚Üí (Machine:KHS)</code>
            <br><br>
            <strong style="color:#CDD9E5;">Why a graph?</strong> No other database efficiently answers: "find all alarms
            related to the cooling system across all machines, and show which components they share." Graph traversal is
            the only fast way to answer multi-hop relationship queries.
          </div>
          <span class="node-tag">RELATIONSHIP QUERIES</span>
        </div>

        <!-- STRUCTURED -->
        <div class="node green">
          <span class="node-icon">üóÑ</span>
          <div class="node-title">Structured Extraction</div>
          <div class="node-sub">MongoDB</div>
          <div class="node-desc">
            The platform knows about named schema types: <strong style="color:#3ACF7A;">alarm</strong> and <strong
              style="color:#3ACF7A;">parameter</strong>. It runs a structured extraction pass to pull every alarm record
            from every document and store it as a typed record.
            <br><br>
            <code
              style="font-family:monospace;font-size:10px;color:#3ACF7A;">{ alarm_id, description, cause, remedy, machine, doc_id }</code>
            <br><br>
            <strong style="color:#CDD9E5;">Why MongoDB?</strong> Document database optimized for exact-match field
            queries. <code style="color:#3ACF7A;">find({machine:"KHS"})</code> returns all alarms for that machine
            instantly. This is the only layer your service layer queries directly.
          </div>
          <span class="node-tag">YOUR APP READS THIS</span>
        </div>

      </div>

      <!-- storage row labels -->
      <div class="storage-row" style="margin-top:8px;">
        <div class="storage-node" style="border-color:#1E3050;">
          <div class="s-name" style="color:#4D9EFF;">Azure Blob</div>
          <div class="s-type">raw ¬∑ blob store</div>
        </div>
        <div class="storage-node" style="border-color:#251E40;">
          <div class="s-name" style="color:#A47FE8;">Vector Index</div>
          <div class="s-type">embeddings ¬∑ ~1536d</div>
        </div>
        <div class="storage-node" style="border-color:#251E40;">
          <div class="s-name" style="color:#C792EA;">Snowflake Tables</div>
          <div class="s-type">structured data ¬∑ SQL</div>
        </div>
        <div class="storage-node" style="border-color:#0E2028;">
          <div class="s-name" style="color:#2FD8C4;">Neo4j Graph</div>
          <div class="s-type">nodes ¬∑ edges ¬∑ paths</div>
        </div>
        <div class="storage-node" style="border-color:#0E2A14;">
          <div class="s-name" style="color:#3ACF7A;">MongoDB</div>
          <div class="s-type">alarm ¬∑ param ¬∑ records</div>
        </div>
      </div>

      <div class="arrow-row" style="margin-top:16px;">
        <div class="arrow">
          <div class="arrow-label">GET /alarms?machine=KHS_Filler ‚Üí structured records</div>
          <div class="arrow-line green-flow" style="height:32px;"></div>
        </div>
      </div>

      <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê PHASE D: AGENT ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
      <div class="phase-label">D ‚Äî Agent ¬∑ Records mapped to Industrail_App schema</div>

      <div class="flow-row cols-3">

        <div class="node green">
          <span class="node-icon">üóÇ</span>
          <div class="node-title">ExtractionAgent ‚Äî Field Mapping</div>
          <div class="node-sub">schemas.py ¬∑ no LLM here</div>
          <div class="node-desc">
            Receives the structured alarm records from the Structured layer. Maps each JSON field to the exact column
            name Industrail_App expects.
            <br><br>
            <code style="font-family:monospace;font-size:10px;color:#3ACF7A;">alarm_id ‚Üí "Fault Code *"</code><br>
            <code style="font-family:monospace;font-size:10px;color:#3ACF7A;">description ‚Üí "Fault Name *"</code><br>
            <code style="font-family:monospace;font-size:10px;color:#3ACF7A;">cause ‚Üí "Reason 3"</code><br>
            <code style="font-family:monospace;font-size:10px;color:#3ACF7A;">remedy ‚Üí "Reason 4"</code>
            <br><br>
            Column schema is defined in schemas.py ‚Äî the agent imports it, never hardcodes it.
          </div>
          <span class="node-tag">DETERMINISTIC MAPPING</span>
        </div>

        <div class="node amber">
          <span class="node-icon">üè∑</span>
          <div class="node-title">ReasonClassifier</div>
          <div class="node-sub">regex primary ¬∑ Ollama fallback</div>
          <div class="node-desc">
            Classifies each alarm into Industrail_App's own taxonomy ‚Äî these fields are not in the PDF, they are
            Industrail_App-specific.
            <br><br>
            <strong style="color:#CDD9E5;">Reason 1</strong> ‚Üí one of 3 fixed Industrail_App categories<br>
            <strong style="color:#CDD9E5;">Reason 2</strong> ‚Üí Electrical / Mechanical / Sensor / Software<br>
            <strong style="color:#CDD9E5;">Category Type</strong> ‚Üí Planned / Unplanned Downtime
            <br><br>
            Regex runs first (fast, deterministic). LLM (Ollama, local) only runs when regex confidence is below
            threshold. ClassificationCache prevents re-classifying the same alarm twice.
          </div>
          <span class="node-tag">REGEX + LLM CLASSIFY</span>
        </div>

        <div class="node blue">
          <span class="node-icon">üíæ</span>
          <div class="node-title">Local MongoDB Cache</div>
          <div class="node-sub">database.py ¬∑ upsert by (md5, alarm_id)</div>
          <div class="node-desc">
            After classification, records are saved to a local MongoDB instance. Upsert logic (insert or update) ensures
            the same alarm is never duplicated even if the same PDF is processed twice.
            <br><br>
            <strong style="color:#CDD9E5;">Why cache locally?</strong> If the platform API is slow or unavailable, the
            app still generates the spreadsheet from cache. It also means re-generating a spreadsheet for the same
            machine is instant ‚Äî no re-query to the platform.
            <br><br>
            Collections: <code style="color:#4D9EFF;">alarms ¬∑ parameters ¬∑ processed_files</code>
          </div>
          <span class="node-tag">RESILIENCE CACHE</span>
        </div>

      </div>

      <div class="arrow-row">
        <div class="arrow">
          <div class="arrow-label">typed records ‚Üí generator</div>
          <div class="arrow-line green-flow" style="height:28px;"></div>
        </div>
      </div>

      <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê PHASE E: GENERATE ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
      <div class="phase-label">E ‚Äî Generate ¬∑ Spreadsheet written to disk</div>

      <div class="flow-row cols-2">

        <div class="node teal">
          <span class="node-icon">‚ö°</span>
          <div class="node-title">PhaseEngine</div>
          <div class="node-sub">phase_engine.py ¬∑ tab selector</div>
          <div class="node-desc">
            Reads the current phase configuration and decides which tabs to populate in the output file.
            <br><br>
            <strong style="color:#2FD8C4;">Phase 1</strong> ‚Üí Downtime Configuration + Parameter Specifications (2
            tabs)<br>
            <strong style="color:#2FD8C4;">Phase 2</strong> ‚Üí + OEE, Machine Details, Product Config, Waste Config (6
            more tabs)<br>
            <strong style="color:#2FD8C4;">Phase 3</strong> ‚Üí Full 13-tab output
            <br><br>
            Adding a new tab = add its schema to schemas.py. PhaseEngine picks it up automatically.
          </div>
          <span class="node-tag">TAB SELECTOR</span>
        </div>

        <div class="node green">
          <span class="node-icon">üìä</span>
          <div class="node-title">SpreadsheetGenerator</div>
          <div class="node-sub">openpyxl ¬∑ .xlsx ‚Äî not CSV</div>
          <div class="node-desc">
            Creates a proper .xlsx workbook with named worksheets. Each worksheet is one Industrail_App tab. Writes the header
            row from schemas.py column list, then writes each record row by row.
            <br><br>
            Special handling: Fault Code leading zeros preserved as string (<code
              style="color:#3ACF7A;">str(id).zfill(4)</code>) ‚Äî Excel strips leading zeros if written as numbers.
            <br><br>
            Output file: <code style="color:#3ACF7A;">machine_KHS_Filler_2026-02-23.xlsx</code> ‚Äî ready to import into
            Industrail_App with zero manual edits.
          </div>
          <span class="node-tag">FINAL OUTPUT</span>
        </div>

      </div>

      <div class="arrow-row">
        <div class="arrow">
          <div class="arrow-label">download</div>
          <div class="arrow-line green-flow" style="height:24px;"></div>
        </div>
      </div>

      <div class="flow-row cols-1">
        <div class="node"
          style="border-color:var(--green); border-style:dashed; background:var(--green-bg); text-align:center; padding:24px;">
          <div style="font-family:var(--mono); font-size:13px; font-weight:600; color:var(--green); margin-bottom:6px;">
            üì• machine_KHS_Filler_2026-02-23.xlsx
          </div>
          <div style="font-size:12px; color:var(--muted);">
            13-tab Master Bulk Upload ¬∑ ready for Industrail_App import ¬∑ zero manual editing
          </div>
        </div>
      </div>

    </div><!-- /pipeline -->

    <!-- LEGEND -->
    <div class="legend">
      <div class="legend-item">
        <div class="legend-dot" style="background:var(--amber);"></div>
        Ingestion / User
      </div>
      <div class="legend-item">
        <div class="legend-dot" style="background:var(--blue);"></div>
        Keyword / Exact Search
      </div>
      <div class="legend-item">
        <div class="legend-dot" style="background:var(--purple);"></div>
        Semantic / Analytics (Cortex)
      </div>
      <div class="legend-item">
        <div class="legend-dot" style="background:var(--teal);"></div>
        Graph / Relationships + PhaseEngine
      </div>
      <div class="legend-item">
        <div class="legend-dot" style="background:var(--green);"></div>
        Structured Data + Output
      </div>
      <div class="legend-item" style="margin-left:auto;">
        <div class="legend-line-h" style="background:var(--green);"></div>
        Main data flow
      </div>
      <div class="legend-item">
        <div class="legend-line-h" style="background:var(--border2);"></div>
        Internal / parallel flow
      </div>
    </div>

    <!-- DIVIDER -->
    <div class="divider"></div>

    <!-- QA SECTION -->
    <div class="qa-section">
      <div class="qa-header">Concept Reference ‚Äî Questions About This System</div>

      <div class="qa-grid">

        <div class="qa-card">
          <div class="qa-q">Why does the platform need 5 separate storage engines? Isn't that over-engineering?</div>
          <div class="qa-a">Each engine is optimized for a completely different query pattern. <strong>MongoDB</strong>
            is fast at exact field lookup (<code>find alarm where machine=X</code>) but cannot rank by keyword
            relevance. <strong>OpenSearch</strong> is fast at BM25 keyword ranking but slow at graph traversal.
            <strong>Neo4j</strong> is fast at multi-hop relationship queries but cannot do semantic similarity. Using
            one engine for everything would mean every query is slow because the engine is not designed for it. This is
            the same reason a car has different gears ‚Äî each optimized for a different speed.
          </div>
        </div>

        <div class="qa-card">
          <div class="qa-q">Why OpenSearch for BM25 and not just MongoDB text search?</div>
          <div class="qa-a">MongoDB has text search but it is basic. <strong>OpenSearch</strong> is purpose-built for
            search ‚Äî it supports BM25 ranking, fuzzy matching, faceted filters, and vector search all in one engine
            under Apache 2.0 license. Critically, it runs natively in AWS (where the platform infrastructure lives),
            supports hybrid BM25 + vector queries in a single request, and scales to millions of documents with
            sub-second response times. MongoDB text search would require you to implement ranking yourself and would
            degrade significantly at scale.</div>
        </div>

        <div class="qa-card">
          <div class="qa-q">What exactly does Cortex do that OpenSearch doesn't?</div>
          <div class="qa-a">OpenSearch handles <strong>retrieval</strong> ‚Äî finding the right documents. Cortex handles
            <strong>analytics and ML</strong> ‚Äî finding patterns across structured data. Cortex runs inside Snowflake
            where all alarm records are stored as SQL tables. It can run predictive models (<em>which machine will have
              the most faults next month?</em>), anomaly detection (<em>this alarm pattern is unusual</em>), and
            LLM-based summarisation (<em>summarise all alarms for the KHS Filler</em>) ‚Äî all without exporting data.
            Cortex is the difference between a search engine and an intelligence layer.
          </div>
        </div>

        <div class="qa-card">
          <div class="qa-q">Why does the service layer have its own local MongoDB if the platform already uses MongoDB?
          </div>
          <div class="qa-a">These are two separate MongoDB instances serving different purposes. The platform's MongoDB
            stores raw extracted records for all machines across all documents. The local MongoDB cache stores
            <strong>classified and mapped records</strong> ‚Äî alarm records that have already gone through
            ReasonClassifier and field mapping. The local cache means: (1) re-generating a spreadsheet for the same
            machine is instant with no API call, (2) the app works if the platform is temporarily unavailable, (3) you
            can track export history locally. Upsert by <code>(source_md5, alarm_id)</code> prevents duplicates.
          </div>
        </div>

        <div class="qa-card">
          <div class="qa-q">Why does the app query MongoDB (Structured layer) and not OpenSearch or Neo4j directly?
          </div>
          <div class="qa-a">The app's query is <strong>structured and known</strong>: "give me all alarm records for
            machine X". This is an exact-match field query ‚Äî the type MongoDB is optimized for. OpenSearch would be used
            if the query was "find documents that mention inverter faults" (keyword ranking needed). Neo4j would be used
            if the query was "find all alarms connected to the cooling system across all machines" (graph traversal
            needed). Since the app knows exactly what it wants (alarm records for a specific machine), the Structured
            layer with MongoDB is the right and fastest answer.</div>
        </div>

        <div class="qa-card">
          <div class="qa-q">What is an embedding and why is it 1536 numbers?</div>
          <div class="qa-a">An embedding is a representation of text as a point in mathematical space where
            <strong>similar meanings are close together</strong>. An embedding model (like OpenAI's
            text-embedding-ada-002 or a Cortex embedding model) reads a text chunk and outputs 1536 numbers ‚Äî each
            number encodes a different aspect of meaning. 1536 is not magic ‚Äî it is the output dimension of that
            specific model. More dimensions = more nuance but more storage. When you search semantically, your query is
            also embedded into 1536 numbers, then the system finds all document vectors that are mathematically close
            (cosine similarity). "Overheating drive" and "inverter overtemperature" will be close in this
            1536-dimensional space.
          </div>
        </div>

        <div class="qa-card">
          <div class="qa-q">Why is the LLM (Ollama) only used for classification and not for extraction?</div>
          <div class="qa-a">Extraction means reading a PDF and pulling out field values ‚Äî this is now handled by the
            platform (Docling parses the PDF, structured extraction fills the MongoDB records). Using an LLM for
            extraction is slow, expensive, and produces inconsistent field names. Classification means deciding which of
            3 fixed categories an alarm belongs to ‚Äî this is a bounded problem where an LLM adds genuine value because
            the categories (<em>Automation / Basic Machine / Rinser-Capper</em>) are Industrail_App-specific and not derivable
            from the PDF text alone. Regex handles the easy cases; LLM handles ambiguous ones. ClassificationCache
            ensures each unique description is classified only once.</div>
        </div>

        <div class="qa-card">
          <div class="qa-q">What problems does this architecture solve that a simple "parse PDF ‚Üí write Excel" script
            would not?</div>
          <div class="qa-a"><strong>Scale:</strong> A script re-parses the PDF every time. This architecture caches
            parsed results ‚Äî same machine, instant output. <strong>Search:</strong> A script has no way to answer "find
            all alarms related to cooling across all machines". The BM25 and semantic indices enable this.
            <strong>Relationships:</strong> A script cannot trace that alarm 282 and alarm 310 both involve the same
            inverter component. Neo4j enables this. <strong>Analytics:</strong> A script cannot predict fault frequency
            or detect anomalies. Cortex enables this. <strong>Resilience:</strong> A script fails if the PDF format
            changes. A multi-engine platform degrades gracefully ‚Äî if semantic search fails, BM25 still works.
          </div>
        </div>

      </div>
    </div>

  </div>
</body>

</html>
